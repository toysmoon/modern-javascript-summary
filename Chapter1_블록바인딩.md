
# 블록바인딩
C 기반 언어에서 변수는 선언한 위치에서 바로 만들어진다. 자바스크립트에서는 이와 달리 변수 선언 방식에 따라 변수 생성 위치가 다르다. 기존 var 선언이 왜 혼란스러운지 설명하고, ESMAScript 6의 블록 바인딩을 소개한다.
## var 선언과 호이스팅
var를 이용하여 변수를 선언하면 선언한 위치와 상관없이 맨 위에 있는 것처럼 처리된다. 이것을 **호이스팅**(hoisting)이라고 부른다.

ESMAScript 6에서는 변수 생명 주기를 제어하기 위해 블록 레벨 스코프 옵션이 도입되었다.
## 블록-레벨 선언
블록 스코프 밖에서는 접근할 수 없는 바인딩을 선언하는 것.
- 함수 내부
- 블록 내부({ 와 }를 사용하여 지정)
### let 선언
- let으로 대체된 변수의 스코프는 현재의 코드 블록으로 제한된다. 
- let 선언은 선언된 블록의 맨 위로 호이스팅 되지 않는다.
### 재정의 금지
- 식별자가 특정 스코프 안에 선언되어 있을 경우, 스코프 안에서 let 선언으로 식별자를 사용하면 에러가 발생한다.
- let 선언을 사용하여, 새 변수를 블록 스코프 내부에 만든다면 에러가 발생하지 않는다.
### const 선언
- const를 사용하여 선언된 바인딩은 **상수**(constants)로 간주되며, 설정하면 변경할 수 없다. 
- 모든 const 바인딩은 선언할 때 **초기화**해야 한다.
  #### constants
  상수(constants) 역시 선언된 블록 바깥에서는 더 이상 접근할 수 없으며, 호이스팅되지 않는다.
  #### const로 객체 선언하기
  const 선언은 바인딩을 변경하지 못하도록 하는 것이지, 바인딩 된 값의 변경을 막는 것은 아니다.
### 임시 접근 불가구역
- let이나 const로 선언한 변수는 선언하기 전에 변수에 접근할 수 없다.
- 블록 내부에 let이나 const가 존재하면 임시 접근 불가구역(Temporal Dead Zone, TDZ)이라고 부르는 곳에 value가 존재하게 된다.
- 이 규칙은 let이나 const로 선언한 변수를 정의하지 전에 사용하려 할 때 항상 적용된다.
```javascript
console.log(typeof value);  // "undefined"
console.log(typeof errorValue); // 에러 발생
if (condition) {
  let value == "blue";
}
let errorValue;
```
## 반복문 안에서의 블록 바인딩
반복문 내에서 블록 레벨 변수 스코프로 동작하게 하려면 let을 사용해야 한다.
### 반복문에서의 let 선언
var는 반복문 안에서 사용한 변수에 외부에서도 접근할 수 있게 하기 때문에 반복문 내에 함수를 만들 때 문제를 발생시켜왔다. let 선언은 반복할 때마다 매번 새 변수 i를 만들고, 반복문 안에서 만들어진 함수는 i의 복사본을 얻을 수 있다.
### 반복문에서의 const 선언
- 일반적인 for문의 경우 변수 초기화에 const를 사용할 수 있지만, 그 값을 변경하려고 하면 에러가 발생한다.
- 반면에 const 변수가 for-in이나 for-of문  안에서 사용될 때는 let 변수와 비슷하게 동작한다.
## 전역 블록 바인딩
- var를 전역 스코프에서 사용하면 전역 객체의 프로퍼티로 새로운 전역 변수를 생성한다.
- 전역 스코프에 var 대신 let이나 const를 사용하면, 새로운 바인딩이 전역 스코프에 생성되지만 전역 객체의 프로퍼티로 추가되지는 않는다.
```javascript
//브라우저 내에서
let RegExp = "Hello!";
console.log(RegExp);                    // "Hello!"
console.log(window.RegExp === RegExp);  // false

const ncz = "Hi!"
console.log(ncz);                       // "Hi!"
console.log("ncz" in window)!           // false
```
> 만약 전역 객체를 이용해야 한다면 여전히 전역 스코프에 var를 사용할 수 있다. 브라우저에서 프레임이나 윈도우 전역에서 코드에 접근하려 할 때는 이 방법이 가장 일반적인 방법이다.
## 블록 바인딩을 위한 모범 사례
const를 기본으로 사용하고 변수 값을 변경해야 할 때만 let을 사용하는 것이다. 예상치 못한 값 변경은 버그의 원인이 될 수 있기 때문이다.
